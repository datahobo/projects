temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
}
}
return(setsByYear)
}
getBricksetSetsByYear <- function (api.url, api.key, u.hash, year) {
# assumes that there is at least one set in the request
i <- 1
# testing
setsByYear <- NULL
temp <- NULL
# start with the first one
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function doesn't return false, there are more sets to get
moreSets <- !is.logical(setsByYear)
# keep going...
while (moreSets) {
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function returns false, we've hit the end of the list
if (is.logical(temp)) {
moreSets <- FALSE
} else {
# Let's fix these so they have the same variables in the same order
# are they different lengths?
if (length(names(setsByYear)) > length(names(temp))) {
# the temp list is shorter (assume it has a subset of the variables)
# in the setsByYear list
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (j in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
temp[1, ncol(temp) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(temp)[ncol(temp)] <- colsToAdd[j]
}
}
if (length(names(temp)) > length(names(setsByYear))) {
# the setsByYear list is shorter (assume it has a subset of the variables)
# in the temp list
colsToAdd <- setdiff(names(temp), names(setsByYear))
for (k in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[k]
}
}
# now they are the same length
# do they have elements in the same order?
if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {
# if not, put them in the same order
temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
}
}
return(setsByYear)
}
sets2013 <- getBricksetSetsByYear(api.url, api.key, u.hash, year = 2013)
sets2013 <- sets2013[names(sets2014)]
setsByYear <- rbind(sets2014, sets2013)
rm(sets2013, sets2014)
write.csv(setsByYear)
write.csv(setsByYear, "setsByYear.csv")
for (y in seq(2012, 1970, -1)) {
temp <- getBricksetSetsByYear(api.url, api.key, u.hash, year = y)
temp <- temp[names(setsByYear)]
setsByYear <- rbind(setsByYear, temp)
print(y)
}
View(temp)
table(setsByYear$year)
write.csv(setsByYear, "setsByYear.csv")
for (y in seq(2010, 1970, -1)) {
temp <- getBricksetSetsByYear(api.url, api.key, u.hash, year = y)
temp <- temp[names(setsByYear)]
setsByYear <- rbind(setsByYear, temp)
# hopefully this will set it up to update the environment with data...
print(y)
}
table(setsByYear$year)
write.csv(setsByYear, "setsByYear.csv")
# Here are the packages that you'll need: ----
library(XML)
library(stringr)
library(RCurl)
library(plyr)
table(setsByYear$year)
for (y in seq(1997, 1970, -1)) {
temp <- getBricksetSetsByYear(api.url, api.key, u.hash, year = y)
temp <- temp[names(setsByYear)]
setsByYear <- rbind(setsByYear, temp)
# hopefully this will set it up to update the environment with data...
print(y)
}
write.csv(setsByYear, "setsByYear.csv")
for (y in seq(1969, 1960, -1)) {
temp <- getBricksetSetsByYear(api.url, api.key, u.hash, year = y)
temp <- temp[names(setsByYear)]
setsByYear <- rbind(setsByYear, temp)
# hopefully this will set it up to update the environment with data...
print(y)
}
table(setsByYear$year)
write.csv(setsByYear, "setsByYear.csv")
str_peeronPartsListURL <- function (setID) {
# This is to get the list of parts associated with a set
urlString <- "http://www.peeron.com/inv/sets/"
urlString <- paste(urlString, setID, sep = "", collapse = NULL)
return(urlString)
}
library(XML)
library(stringr)
dfr_cleanPeeronPartsList <- function (partsList) {
# First we need the right headers...
tempHeader <- colnames(partsList)
tempHeader <- str_replace_all(tempHeader, "NULL", "")
tempHeader <- str_replace_all(tempHeader, "[.]", "")
colnames(partsList) <- tempHeader
# This works with a data frame coming out of the peeron import
partsList$Qty <- as.numeric(levels(partsList$Qty))[partsList$Qty]
partsList$PartNum <- as.character(partsList$PartNum)
partsList$Color <- as.character(partsList$Color)
partsList$Description <- as.character(partsList$Description)
partsList$Note <- as.character(partsList$Note)
return(partsList)
}
# Let's create a function to get all the parts from a parts list
dfr_peeronPartsList <- function (setIDString) {
# Define the URL we're going to get
setURL <- str_peeronPartsListURL(setIDString)
# Now pull the page into an R object
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
# Add the setNumber to the data frame
setPartsList$SetID <- setIDString
# Use the function to clean the data frame
setPartsList <- dfr_cleanPeeronPartsList(setPartsList)
return(setPartsList)
}
View(setsByYear)
!is.na(setsByYear$USRetailPrice)
mean(is.numeric(!is.na(setsByYear$USRetailPrice)))
mean(as.numeric(!is.na(setsByYear$USRetailPrice)))
table(setsByYear$USRetailPrice)
length(table(setsByYear$USRetailPrice))
table(setsByYear$USRetailPrice == '')
table(setsByYear$USRetailPrice == '') / nrow(setsByYear)
round(table(setsByYear$USRetailPrice == '') / nrow(setsByYear) * 100, 0)
str_peeronSetListURL <- function (page) {
# This is for the list of sets available on Peeron
urlString <- 'http://www.peeron.com/cgi-bin/invcgis/setsearch?Inv=YES&PagerSortDir=r&PagerSortCol=MSRP&PagerSortRev=1'
urlString <- paste(urlString, "&PagerPage=", as.character(page), sep = "", collapse = NULL)
return(urlString)
}
# Now we'll create some functions to re-cast the columns in each of our data frames...
dfr_cleanPeeronSetList <- function (setList) {
# First we need to fix the column names
# Make sure you load stringr!
tempHeader <- colnames(setList)
tempHeader <- str_replace_all(tempHeader, "NULL", "")
tempHeader <- str_replace_all(tempHeader, "[.]", "")
colnames(setList) <- tempHeader
# Now we can update the types...
# This works with a dataframe coming out of the peeron import
setList$SetID <- as.character(setList$SetID)
setList$Name <- as.character(setList$Name)
setList$Theme <- as.character(setList$Theme)
# Ahhh....factors
setList$Year <- as.numeric(levels(setList$Year))[setList$Year]
setList$Pcs <- as.numeric(levels(setList$Pcs))[setList$Pcs]
setList$Figs <- as.numeric(levels(setList$Figs))[setList$Figs]
# We'll do a little more work with this one
setList$MSRP <- as.character(setList$MSRP)
setList$MSRP <- str_replace_all(setList$MSRP, '\\$','')
setList$MSRP <- as.numeric(setList$MSRP)
setList$Inventory <- as.character(setList$Inventory)
setList$Instructions <- as.character(setList$Instructions)
return(setList)
}
brickSets <- setsByYear
rm(setsByYear, temp, i, j, moreSets)
rm(year)
}
str_peeronPartsListURL <- function (setID) {
# This is to get the list of parts associated with a set
urlString <- "http://www.peeron.com/inv/sets/"
urlString <- paste(urlString, setID, sep = "", collapse = NULL)
return(urlString)
}
# Now we'll create some functions to re-cast the columns in our parts list....
dfr_cleanPeeronPartsList <- function (partsList) {
# First we need the right headers...
tempHeader <- colnames(partsList)
tempHeader <- str_replace_all(tempHeader, "NULL", "")
tempHeader <- str_replace_all(tempHeader, "[.]", "")
colnames(partsList) <- tempHeader
# This works with a data frame coming out of the peeron import
partsList$Qty <- as.numeric(levels(partsList$Qty))[partsList$Qty]
partsList$PartNum <- as.character(partsList$PartNum)
partsList$Color <- as.character(partsList$Color)
partsList$Description <- as.character(partsList$Description)
partsList$Note <- as.character(partsList$Note)
return(partsList)
}
# Let's create a function to get all the parts from a parts list
dfr_peeronPartsList <- function (setIDString) {
# Define the URL we're going to get
setURL <- str_peeronPartsListURL(setIDString)
# Now pull the page into an R object
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
# Add the setNumber to the data frame
setPartsList$SetID <- setIDString
# Use the function to clean the data frame
setPartsList <- dfr_cleanPeeronPartsList(setPartsList)
return(setPartsList)
}
# Let's use paste because it's part of the base package
str_peeronSetListURL <- function (page) {
# This is for the list of sets available on Peeron
urlString <- 'http://www.peeron.com/cgi-bin/invcgis/setsearch?Inv=YES&PagerSortDir=r&PagerSortCol=MSRP&PagerSortRev=1'
urlString <- paste(urlString, "&PagerPage=", as.character(page), sep = "", collapse = NULL)
return(urlString)
}
# Now we'll create some functions to re-cast the columns in each of our data frames...
dfr_cleanPeeronSetList <- function (setList) {
# First we need to fix the column names
# Make sure you load stringr!
tempHeader <- colnames(setList)
tempHeader <- str_replace_all(tempHeader, "NULL", "")
tempHeader <- str_replace_all(tempHeader, "[.]", "")
colnames(setList) <- tempHeader
# Now we can update the types...
# This works with a dataframe coming out of the peeron import
setList$SetID <- as.character(setList$SetID)
setList$Name <- as.character(setList$Name)
setList$Theme <- as.character(setList$Theme)
# Ahhh....factors
setList$Year <- as.numeric(levels(setList$Year))[setList$Year]
setList$Pcs <- as.numeric(levels(setList$Pcs))[setList$Pcs]
setList$Figs <- as.numeric(levels(setList$Figs))[setList$Figs]
# We'll do a little more work with this one
setList$MSRP <- as.character(setList$MSRP)
setList$MSRP <- str_replace_all(setList$MSRP, '\\$','')
setList$MSRP <- as.numeric(setList$MSRP)
setList$Inventory <- as.character(setList$Inventory)
setList$Instructions <- as.character(setList$Instructions)
return(setList)
}
peeronSets <- NULL
for(i in 1:1) {
listURL <- str_peeronSetListURL(i)
# Then download that page
listPage <- readHTMLTable(listURL, header = TRUE)
# Put the right table into a dataframe
peeronSetsList <- NULL
peeronSetsList <- as.data.frame(listPage[2])
# Now clean up the table
peeronSetsList <- dfr_cleanedPeeronSetListForMerge(peeronSetsList)
# Now all we need is a merging function...
peeronSets <- rbind(peeronSets, peeronSetsList)
}
library(XML)
library(stringr)
peeronSets <- NULL
# for(i in 1:48) {
for(i in 1:1) {
# There are 48 pages of sets that have prices
# First we get a URL
listURL <- str_peeronSetListURL(i)
# Then download that page
listPage <- readHTMLTable(listURL, header = TRUE)
# Put the right table into a dataframe
peeronSetsList <- NULL
peeronSetsList <- as.data.frame(listPage[2])
# Now clean up the table
peeronSetsList <- dfr_cleanedPeeronSetListForMerge(peeronSetsList)
# Now all we need is a merging function...
peeronSets <- rbind(peeronSets, peeronSetsList)
}
peeronSets <- NULL
# for(i in 1:48) {
for(i in 1:1) {
# There are 48 pages of sets that have prices
# First we get a URL
listURL <- str_peeronSetListURL(i)
# Then download that page
listPage <- readHTMLTable(listURL, header = TRUE)
# Put the right table into a dataframe
peeronSetsList <- NULL
peeronSetsList <- as.data.frame(listPage[2])
# Now clean up the table
peeronSetsList <- dfr_cleanPeeronSetList(peeronSetsList)
# Now all we need is a merging function...
peeronSets <- rbind(peeronSets, peeronSetsList)
}
View(peeronSets)
View(peeronSetsList)
str(peeronSets)
str(peeronSetsList)
rm(i, listURL, listPage)
rm(colsToAdd)
peeronSets <- NULL
for(i in 1:48) {
# for(i in 1:1) {
# There are 48 pages of sets that have prices
# First we get a URL
listURL <- str_peeronSetListURL(i)
# Then download that page
listPage <- readHTMLTable(listURL, header = TRUE)
# Put the right table into a dataframe
peeronSetsList <- NULL
peeronSetsList <- as.data.frame(listPage[2])
# Now clean up the table
peeronSetsList <- dfr_cleanPeeronSetList(peeronSetsList)
# Now all we need is a merging function...
peeronSets <- rbind(peeronSets, peeronSetsList)
}
rm(i, listURL, listPage, peeronSets)
peeronSets <- NULL
for(i in 1:88) {
# for(i in 1:1) {
# There are 48 pages of sets that have prices
# First we get a URL
listURL <- str_peeronSetListURL(i)
# Then download that page
listPage <- readHTMLTable(listURL, header = TRUE)
# Put the right table into a dataframe
peeronSetsList <- NULL
peeronSetsList <- as.data.frame(listPage[2])
# Now clean up the table
peeronSetsList <- dfr_cleanPeeronSetList(peeronSetsList)
# Now all we need is a merging function...
peeronSets <- rbind(peeronSets, peeronSetsList)
}
rm(i, listURL, listPage, peeronSetsList)
rm(y, temp)
write.csv(peeronSets, "peeronSets.csv")
write.csv(brickSets, "brickSets.csv")
table(brickSets$USRetailPrice)
(brickSets$USRetailPrice == '') / nrow(brickSets)
length(brickSets$USRetailPrice == '') / nrow(brickSets)
nrow(brickSets$USRetailPrice == '') / nrow(brickSets)
table(brickSets$USRetailPrice == '') / nrow(brickSets)
round(table(brickSets$USRetailPrice == '') / nrow(brickSets) * 100, 0)
table(peeronSets$MSRP)
table(is.na(peeronSets$MSRP))
round(table(is.na(peeronSets$MSRP)) / nrow(peeronSets) * 100, 0)
brickSetPriceIDs <- brickSets[brickSets$USRetailPrice != '']
brickSetPriceIDs <- brickSets[, brickSets$USRetailPrice != '']
brickSetPriceIDs <- brickSets[brickSets$USRetailPrice != '', ]
View(brickSetPriceIDs)
brickSetsPriced <- brickSets[brickSets$USRetailPrice != '', ]
rm(brickSetPriceIDs)
brickSets$legoID <- paste0(brickSets$number, "-", brickSets$numberVariant)
View(brickSets)
brickSetsPriced <- brickSets[brickSets$USRetailPrice != '', ]
brickSetsPriceIds <- brickSetsPriced$legoID
table(is.na(peeronSets$MSRP))
peeronSetsPriced <- peeronSets[peeronSets$MSRP != NA, ]
peeronSetsPriced <- peeronSets[!is.na(peeronSets$MSRP), ]
names(peeronSets)
peeronSetsPriceIds <- peeronSetsPriced$SetID
brickSetsPriceIds <- data.frame(brickSetsPriced$legoID)
peeronSetsPriceIds <- data.frame(peeronSetsPriced$SetID)
View(peeronSetsPriceIds)
names(brickSetsPriceIds) <- "SetID"
brickSetsPriceIds$datasource <- "brickset"
names(peeronSetsPriceIds) <- "SetID"
brickSetsPriceIds$brickset <- "brickset"
brickSetsPriceIds$datasource <- NULL
peeronSetsPriceIds$peeron <- "peeron"
bothPriced <- merge(brickSetsPriceIds, peeronSetsPriceIds)
View(bothPriced)
table(bothPriced$peeron)
nrow(bothPriced) / nrow(brickSetsPriceIds)
nrow(bothPriced) / nrow(peeronSetsPriceIds)
nrow(bothPriced) - nrow(peeronSetsPriceIds)
tapply(brickSetsPriced$USRetailPrice, brickSetsPriced$year, mean)
warnings
warnings()
View(brickSets)
str(brickSets)
str(brickSets)
brickSets$year <- as.numeric(brickSets$year)
brickSets$pieces <- as.numeric(brickSets$pieces)
table(brickSets$number)
table(brickSets$numberVariant)
brickSets$number <- as.numeric(brickSets$number)
brickSets$numberVariant <- as.numeric(brickSets$numberVariant)
str(brickSets)
brickSets$minifigs <- as.numeric(brickSets$minifigs)
brickSets$image <- as.logical(brickSets$image)
View(brickSets)
brickSets$owned <- as.logical(brickSets$owned)
brickSets$wanted <- as.logical(brickSets$wanted)
View(brickSets)
brickSets$qtyOwned <- as.numeric(brickSets$qtyOwned)
brickSets$ACMDataCount <- as.numeric(brickSets$ACMDataCount)
brickSets$ownedByTotal <- as.numeric(brickSets$ownedByTotal)
brickSets$wantedByTotal <- as.numeric(brickSets$wantedByTotal)
brickSets$UKRetailPrice <- as.numeric(brickSets$UKRetailPrice)
brickSets$USRetailPrice <- as.numeric(brickSets$USRetailPrice)
brickSets$CARetailPrice <- as.numeric(brickSets$CARetailPrice)
brickSets$EURetailPrice <- as.numeric(brickSets$EURetailPrice)
str(brickSets)
brickSets$setID <- as.numeric(brickSets$setID)
str(brickSets)
View(brickSets)
bricks <- read.csv('brickSets.csv')
View(bricks)
brickSets$rating <- as.numeric(brickSets$rating)
brickSets$reviewCount <- as.numeric(brickSets$reviewCount)
brickSets$EAN <- as.numeric(brickSets$EAN)
brickSets$UPC <- as.numeric(brickSets$UPC)
brickSets$additionalImageCount <- as.numeric(brickSets$additionalImageCount)
brickSets <- bricks
rm(bricks)
str(brickSets)
brickSets$legoID <- paste0(brickSets$number, "-", brickSets$numberVariant)
# how many sets have prices?
table(brickSets$USRetailPrice)
round(table(brickSets$USRetailPrice == '') / nrow(brickSets) * 100, 0)
brickSetsPriced <- brickSets[brickSets$USRetailPrice != '', ]
round(table(!is.na(brickSets$USRetailPrice)) / nrow(brickSets) * 100, 0)
brickSetsPriced <- brickSets[!is.na(brickSets$USRetailPrice), ]
brickSetsPriceIds <- data.frame(brickSetsPriced$legoID)
names(brickSetsPriceIds) <- "SetID"
brickSetsPriceIds$brickset <- "brickset"
# peeron
table(is.na(peeronSets$MSRP))
round(table(is.na(peeronSets$MSRP)) / nrow(peeronSets) * 100, 0)
peeronSetsPriced <- peeronSets[!is.na(peeronSets$MSRP), ]
peeronSetsPriceIds <- data.frame(peeronSetsPriced$SetID)
names(peeronSetsPriceIds) <- "SetID"
peeronSetsPriceIds$peeron <- "peeron"
# now match them
bothPriced <- merge(brickSetsPriceIds, peeronSetsPriceIds)
table(bothPriced$peeron)
# what's our match rate?
nrow(bothPriced) / nrow(brickSetsPriceIds)
nrow(bothPriced) / nrow(peeronSetsPriceIds)
# brickset is still much better to use, even though the pricing ratio is the same.
tapply(brickSetsPriced$USRetailPrice, brickSetsPriced$year, mean)
library(ggplot2)
rm(brickSetsPriceIds, peeronSetsPriceIds, bothPriced)
ggplot(brickSetsPriced, aes(x = year, y = USRetailPrice))
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = year, y = USRetailPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = year, y = pieces)) +
geom_point(shape = 1)
?corr
?cor
cor(brickSetsPriced$USRetailPrice, brickSetsPriced$pieces)
cor(brickSetsPriced$USRetailPrice, brickSetsPriced$pieces, na.rm = TRUE)
cor(brickSetsPriced$USRetailPrice, brickSetsPriced$pieces, use = "complete.obs")
ggplot(brickSetsPriced, aes(x = USRetailPrice, y = pieces)) +
geom_point(shape = 1)
library(ggplot2)
library(XML)
library(stringr)
library(RCurl)
library(plyr)
library(XML)
library(stringr)
ggplot(brickSetsPriced, aes(x = USRetailPrice, y = pieces)) +
geom_point(shape = 1)
names(brickSetsPriced)
ggplot(brickSetsPriced, aes(x = owned, y = USRetailPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = ownedByTotal, y = USRetailPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = wantedByTotal, y = USRetailPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = wantedByTotal, y = USRetailPrice)) +
geom_point(shape = 1) +
geom_smooth(method = lm)
ggplot(brickSetsPriced, aes(x = wantedByTotal, y = ownedByTotal)) +
geom_point(shape = 1)
library(quantmod)
install.packages(c("codetools", "colorspace", "ggplot2", "manipulate"))
install.packages("mgcv")
install.packages("Rcpp")
install.packages("RGA")
detach("package:zoo", unload=TRUE)
detach("package:quantmod", unload=TRUE)
library("zoo", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
detach("package:zoo", unload=TRUE)
detach("package:xts", unload=TRUE)
detach("package:TTR", unload=TRUE)
detach("package:utils", unload=TRUE)
library("utils", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library("xts", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
detach("package:xts", unload=TRUE)
library("zoo", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
detach("package:zoo", unload=TRUE)
install.packages("quantmod")
library("zoo", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
detach("package:zoo", unload=TRUE)
install.packages(c("manipulate", "zoo"))
library(ggplot2)
library(quantmod)

temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
}
}
return(setsByYear)
}
u.hash <- getBricksetHashFromLogin(api.url, api.key, uname, pword)
rm(uname, pword)
year <- 2014
sets2014 <- getBricksetSetsByYear(api.url, api.key, u.hash, year = 2014)
getBricksetSetsByYear <- function (api.url, api.key, u.hash, year) {
# assumes that there is at least one set in the request
i <- 1
# start with the first one
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function doesn't return false, there are more sets to get
moreSets <- !is.logical(setsByYear)
# keep going...
while (moreSets) {
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function returns false, we've hit the end of the list
if (is.logical(temp)) {
moreSets <- FALSE
} else {
# Let's fix these so they have the same variables in the same order
# are they different lengths?
if (length(names(setsByYear)) > length(names(temp))) {
# the temp list is shorter (assume it has a subset of the variables)
# in the setsByYear list
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
temp[1, ncol(temp) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(temp)[ncol(temp)] <- colsToAdd[i]
}
}
if (length(names(temp)) > length(names(setsByYear))) {
# the setsByYear list is shorter (assume it has a subset of the variables)
# in the temp list
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[i]
}
}
# now they are the same length
# do they have elements in the same order?
if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {
# if not, put them in the same order
temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
}
}
return(setsByYear)
}
year <- 2014
sets2014 <- getBricksetSetsByYear(api.url, api.key, u.hash, year = 2014)
i <- 1
# start with the first one
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function doesn't return false, there are more sets to get
moreSets <- !is.logical(setsByYear)
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function returns false, we've hit the end of the list
if (is.logical(temp)) {
moreSets <- FALSE
}
length(names(setsByYear)) > length(names(temp))
length(names(temp)) > length(names(setsByYear))
colsToAdd <- setdiff(names(setsByYear), names(temp))
colsToAdd <- setdiff(names(temp), names(setsByYear))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[i]
}
}
# now they are the same length
# do they have elements in the same order?
if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {
# if not, put them in the same order
temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
rm(colsToAdd, i, moreSets)
rm(setsByYear, temp)
year <- 2014
sets2014 <- getBricksetSetsByYear(api.url, api.key, u.hash, year = 2014)
getBricksetSetsByYear <- function (api.url, api.key, u.hash, year) {
# assumes that there is at least one set in the request
i <- 1
# start with the first one
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function doesn't return false, there are more sets to get
moreSets <- !is.logical(setsByYear)
# keep going...
while (moreSets) {
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function returns false, we've hit the end of the list
if (is.logical(temp)) {
moreSets <- FALSE
} else {
# Let's fix these so they have the same variables in the same order
# are they different lengths?
if (length(names(setsByYear)) > length(names(temp))) {
# the temp list is shorter (assume it has a subset of the variables)
# in the setsByYear list
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
temp[1, ncol(temp) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(temp)[ncol(temp)] <- colsToAdd[i]
}
}
if (length(names(temp)) > length(names(setsByYear))) {
# the setsByYear list is shorter (assume it has a subset of the variables)
# in the temp list
colsToAdd <- setdiff(names(temp), names(setsByYear))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[i]
}
}
# now they are the same length
# do they have elements in the same order?
if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {
# if not, put them in the same order
temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
}
}
return(setsByYear)
}
sets2014 <- getBricksetSetsByYear(api.url, api.key, u.hash, year = 2014)
library(XML)
library(stringr)
library(RCurl)
library(plyr)
sets2014 <- getBricksetSetsByYear(api.url, api.key, u.hash, year = 2014)
sys.time()
now()
now
Sys.time()
sets2014 <- getBricksetSetsByYear(api.url, api.key, u.hash, year = 2014)
i <- 1
# start with the first one
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function doesn't return false, there are more sets to get
moreSets <- !is.logical(setsByYear)
# keep going...
while (moreSets) {
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function returns false, we've hit the end of the list
if (is.logical(temp)) {
moreSets <- FALSE
} else {
# Let's fix these so they have the same variables in the same order
# are they different lengths?
if (length(names(setsByYear)) > length(names(temp))) {
# the temp list is shorter (assume it has a subset of the variables)
# in the setsByYear list
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
temp[1, ncol(temp) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(temp)[ncol(temp)] <- colsToAdd[i]
}
}
if (length(names(temp)) > length(names(setsByYear))) {
# the setsByYear list is shorter (assume it has a subset of the variables)
# in the temp list
colsToAdd <- setdiff(names(temp), names(setsByYear))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[i]
}
}
# now they are the same length
# do they have elements in the same order?
if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {
# if not, put them in the same order
temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
print(i)
}
}
View(setsByYear)
i <- 245
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
View(temp)
length(names(setsByYear)) > length(names(temp))
i <- 246
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
if (is.logical(temp)) {
moreSets <- FALSE
} else {
# Let's fix these so they have the same variables in the same order
# are they different lengths?
if (length(names(setsByYear)) > length(names(temp))) {
# the temp list is shorter (assume it has a subset of the variables)
# in the setsByYear list
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
temp[1, ncol(temp) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(temp)[ncol(temp)] <- colsToAdd[i]
}
}
if (length(names(temp)) > length(names(setsByYear))) {
# the setsByYear list is shorter (assume it has a subset of the variables)
# in the temp list
colsToAdd <- setdiff(names(temp), names(setsByYear))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[i]
}
}
# now they are the same length
# do they have elements in the same order?
if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {
# if not, put them in the same order
temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
print(i)
}
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function returns false, we've hit the end of the list
if (is.logical(temp)) {
moreSets <- FALSE
)
if (is.logical(temp)) {
moreSets <- FALSE
}
length(names(setsByYear)) > length(names(temp))
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
temp[1, ncol(temp) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(temp)[ncol(temp)] <- colsToAdd[i]
}
length(names(temp)) > length(names(setsByYear))
mean(as.numeric(names(setsByYear) == names(temp))) != 1
mean(as.numeric(names(setsByYear)
)
)
as.numeric(names(setsByYear) == names(temp))
View(temp)
names(setsByYear) == names(temp)
View(setsByYear)
View(temp)
setsByYear <- rbind(setsByYear, temp)
setsByYear <- NULL
temp <- NULL
i <- 1
# start with the first one
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function doesn't return false, there are more sets to get
moreSets <- !is.logical(setsByYear)
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
is.logical(temp)
length(names(setsByYear)) > length(names(temp))
length(names(temp)) > length(names(setsByYear))
colsToAdd <- setdiff(names(temp), names(setsByYear))
for (i in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[i]
}
i <- 1
setsByYear <- NULL
temp <- NULL
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
moreSets <- !is.logical(setsByYear)
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
length(names(temp)) > length(names(setsByYear))
colsToAdd <- setdiff(names(temp), names(setsByYear))
setsByYear[1, ncol(setsByYear) + 1] <- NA
i <- 1
# testing
setsByYear <- NULL
temp <- NULL
# start with the first one
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function doesn't return false, there are more sets to get
moreSets <- !is.logical(setsByYear)
# keep going...
while (moreSets) {
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function returns false, we've hit the end of the list
if (is.logical(temp)) {
moreSets <- FALSE
} else {
# Let's fix these so they have the same variables in the same order
# are they different lengths?
if (length(names(setsByYear)) > length(names(temp))) {
# the temp list is shorter (assume it has a subset of the variables)
# in the setsByYear list
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (j in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
temp[1, ncol(temp) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(temp)[ncol(temp)] <- colsToAdd[j]
}
}
if (length(names(temp)) > length(names(setsByYear))) {
# the setsByYear list is shorter (assume it has a subset of the variables)
# in the temp list
colsToAdd <- setdiff(names(temp), names(setsByYear))
for (j in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[j]
}
}
# now they are the same length
# do they have elements in the same order?
if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {
# if not, put them in the same order
temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
print(i)
}
}
sets2014 <- setsByYear
setsByYear <- NULL
getBricksetSetsByYear <- function (api.url, api.key, u.hash, year) {
# assumes that there is at least one set in the request
i <- 1
# testing
setsByYear <- NULL
temp <- NULL
# start with the first one
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function doesn't return false, there are more sets to get
moreSets <- !is.logical(setsByYear)
# keep going...
while (moreSets) {
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function returns false, we've hit the end of the list
if (is.logical(temp)) {
moreSets <- FALSE
} else {
# Let's fix these so they have the same variables in the same order
# are they different lengths?
if (length(names(setsByYear)) > length(names(temp))) {
# the temp list is shorter (assume it has a subset of the variables)
# in the setsByYear list
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (j in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
temp[1, ncol(temp) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(temp)[ncol(temp)] <- colsToAdd[j]
}
}
if (length(names(temp)) > length(names(setsByYear))) {
# the setsByYear list is shorter (assume it has a subset of the variables)
# in the temp list
colsToAdd <- setdiff(names(temp), names(setsByYear))
for (j in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[j]
}
}
# now they are the same length
# do they have elements in the same order?
if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {
# if not, put them in the same order
temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
}
}
return(setsByYear)
}
getBricksetSetsByYear <- function (api.url, api.key, u.hash, year) {
# assumes that there is at least one set in the request
i <- 1
# testing
setsByYear <- NULL
temp <- NULL
# start with the first one
setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function doesn't return false, there are more sets to get
moreSets <- !is.logical(setsByYear)
# keep going...
while (moreSets) {
i <- i + 1
temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)
# if the function returns false, we've hit the end of the list
if (is.logical(temp)) {
moreSets <- FALSE
} else {
# Let's fix these so they have the same variables in the same order
# are they different lengths?
if (length(names(setsByYear)) > length(names(temp))) {
# the temp list is shorter (assume it has a subset of the variables)
# in the setsByYear list
colsToAdd <- setdiff(names(setsByYear), names(temp))
for (j in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
temp[1, ncol(temp) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(temp)[ncol(temp)] <- colsToAdd[j]
}
}
if (length(names(temp)) > length(names(setsByYear))) {
# the setsByYear list is shorter (assume it has a subset of the variables)
# in the temp list
colsToAdd <- setdiff(names(temp), names(setsByYear))
for (k in 1:length(colsToAdd)) {
# add another column, and set it's value to NA
setsByYear[1, ncol(setsByYear) + 1] <- NA
# name the last column in the df (the one just added)
# with the name of the next item in the array
names(setsByYear)[ncol(setsByYear)] <- colsToAdd[k]
}
}
# now they are the same length
# do they have elements in the same order?
if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {
# if not, put them in the same order
temp <- temp[names(setsByYear)]
}
# now they have the same length, and are in the same order
setsByYear <- rbind(setsByYear, temp)
}
}
return(setsByYear)
}
sets2013 <- getBricksetSetsByYear(api.url, api.key, u.hash, year = 2013)
sets2013 <- sets2013[names(sets2014)]
setsByYear <- rbind(sets2014, sets2013)
rm(sets2013, sets2014)
write.csv(setsByYear)
write.csv(setsByYear, "setsByYear.csv")
for (y in seq(2012, 1970, -1)) {
temp <- getBricksetSetsByYear(api.url, api.key, u.hash, year = y)
temp <- temp[names(setsByYear)]
setsByYear <- rbind(setsByYear, temp)
print(y)
}
View(temp)
table(setsByYear$year)
write.csv(setsByYear, "setsByYear.csv")
for (y in seq(2010, 1970, -1)) {
temp <- getBricksetSetsByYear(api.url, api.key, u.hash, year = y)
temp <- temp[names(setsByYear)]
setsByYear <- rbind(setsByYear, temp)
# hopefully this will set it up to update the environment with data...
print(y)
}
table(setsByYear$year)
write.csv(setsByYear, "setsByYear.csv")

table(brickSets$numberVariant)
brickSets$number <- as.numeric(brickSets$number)
brickSets$numberVariant <- as.numeric(brickSets$numberVariant)
str(brickSets)
brickSets$minifigs <- as.numeric(brickSets$minifigs)
brickSets$image <- as.logical(brickSets$image)
View(brickSets)
brickSets$owned <- as.logical(brickSets$owned)
brickSets$wanted <- as.logical(brickSets$wanted)
View(brickSets)
brickSets$qtyOwned <- as.numeric(brickSets$qtyOwned)
brickSets$ACMDataCount <- as.numeric(brickSets$ACMDataCount)
brickSets$ownedByTotal <- as.numeric(brickSets$ownedByTotal)
brickSets$wantedByTotal <- as.numeric(brickSets$wantedByTotal)
brickSets$UKRetailPrice <- as.numeric(brickSets$UKRetailPrice)
brickSets$USRetailPrice <- as.numeric(brickSets$USRetailPrice)
brickSets$CARetailPrice <- as.numeric(brickSets$CARetailPrice)
brickSets$EURetailPrice <- as.numeric(brickSets$EURetailPrice)
str(brickSets)
brickSets$setID <- as.numeric(brickSets$setID)
str(brickSets)
View(brickSets)
bricks <- read.csv('brickSets.csv')
View(bricks)
brickSets$rating <- as.numeric(brickSets$rating)
brickSets$reviewCount <- as.numeric(brickSets$reviewCount)
brickSets$EAN <- as.numeric(brickSets$EAN)
brickSets$UPC <- as.numeric(brickSets$UPC)
brickSets$additionalImageCount <- as.numeric(brickSets$additionalImageCount)
brickSets <- bricks
rm(bricks)
str(brickSets)
brickSets$legoID <- paste0(brickSets$number, "-", brickSets$numberVariant)
# how many sets have prices?
table(brickSets$USRetailPrice)
round(table(brickSets$USRetailPrice == '') / nrow(brickSets) * 100, 0)
brickSetsPriced <- brickSets[brickSets$USRetailPrice != '', ]
round(table(!is.na(brickSets$USRetailPrice)) / nrow(brickSets) * 100, 0)
brickSetsPriced <- brickSets[!is.na(brickSets$USRetailPrice), ]
brickSetsPriceIds <- data.frame(brickSetsPriced$legoID)
names(brickSetsPriceIds) <- "SetID"
brickSetsPriceIds$brickset <- "brickset"
# peeron
table(is.na(peeronSets$MSRP))
round(table(is.na(peeronSets$MSRP)) / nrow(peeronSets) * 100, 0)
peeronSetsPriced <- peeronSets[!is.na(peeronSets$MSRP), ]
peeronSetsPriceIds <- data.frame(peeronSetsPriced$SetID)
names(peeronSetsPriceIds) <- "SetID"
peeronSetsPriceIds$peeron <- "peeron"
# now match them
bothPriced <- merge(brickSetsPriceIds, peeronSetsPriceIds)
table(bothPriced$peeron)
# what's our match rate?
nrow(bothPriced) / nrow(brickSetsPriceIds)
nrow(bothPriced) / nrow(peeronSetsPriceIds)
# brickset is still much better to use, even though the pricing ratio is the same.
tapply(brickSetsPriced$USRetailPrice, brickSetsPriced$year, mean)
library(ggplot2)
rm(brickSetsPriceIds, peeronSetsPriceIds, bothPriced)
ggplot(brickSetsPriced, aes(x = year, y = USRetailPrice))
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = year, y = USRetailPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = year, y = pieces)) +
geom_point(shape = 1)
?corr
?cor
cor(brickSetsPriced$USRetailPrice, brickSetsPriced$pieces)
cor(brickSetsPriced$USRetailPrice, brickSetsPriced$pieces, na.rm = TRUE)
cor(brickSetsPriced$USRetailPrice, brickSetsPriced$pieces, use = "complete.obs")
ggplot(brickSetsPriced, aes(x = USRetailPrice, y = pieces)) +
geom_point(shape = 1)
library(ggplot2)
library(XML)
library(stringr)
library(RCurl)
library(plyr)
library(XML)
library(stringr)
ggplot(brickSetsPriced, aes(x = USRetailPrice, y = pieces)) +
geom_point(shape = 1)
names(brickSetsPriced)
ggplot(brickSetsPriced, aes(x = owned, y = USRetailPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = ownedByTotal, y = USRetailPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = wantedByTotal, y = USRetailPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = wantedByTotal, y = USRetailPrice)) +
geom_point(shape = 1) +
geom_smooth(method = lm)
ggplot(brickSetsPriced, aes(x = wantedByTotal, y = ownedByTotal)) +
geom_point(shape = 1)
library(quantmod)
install.packages(c("codetools", "colorspace", "ggplot2", "manipulate"))
install.packages("mgcv")
install.packages("Rcpp")
install.packages("RGA")
detach("package:zoo", unload=TRUE)
detach("package:quantmod", unload=TRUE)
library("zoo", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
detach("package:zoo", unload=TRUE)
detach("package:xts", unload=TRUE)
detach("package:TTR", unload=TRUE)
detach("package:utils", unload=TRUE)
library("utils", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library("xts", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
detach("package:xts", unload=TRUE)
library("zoo", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
detach("package:zoo", unload=TRUE)
install.packages("quantmod")
library("zoo", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
detach("package:zoo", unload=TRUE)
install.packages(c("manipulate", "zoo"))
library(ggplot2)
library(quantmod)
library(ggplot2)
library(quantmod)
?getSymbols
showSymbols
showSymbols()
temp <- getSymbols(Symbols = "CPIAUCSL",
src = 'FRED')
getSymbols(Symbols = "CPIAUCSL",
src = 'FRED')
rm(temp)
tail(CPIAUCSL)
head(CPIAUCSL)
avg.cpi <- apply.yearly(CPIAUCSL, mean)
head(avg.cpi)
avg.cpi <- data.frame(avg.cpi)
View(avg.cpi)
library(stringr)
avg.cpi$year <- str_sub(row.names(avg.cpi), start = 1, end = 4)
View(avg.cpi)
View(avg.cpi)
avg.cpi$year <- as.numeric(str_sub(row.names(avg.cpi), start = 1, end = 4))
names(avg.cpi) <- c("CPI", "year")
brickSetsPriced <- merge(brickSetsPriced, avg.cpi)
View(brickSetsPriced)
max(brickSetsPriced$CPI)
min(brickSetsPriced$CPI)
brickSetsPriced$USAdjustedPrice <- brickSetsPriced$USRetailPrice / brickSetsPriced$CPI * 100
ggplot(brickSetsPriced, aes(x = USRetailPrice, y = USAdjustedPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = USRetailPrice, y = CPI)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = CPI, y = USAdjustedPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = CPI, y = USRetailPrice)) +
geom_point(shape = 1)
ggplot(brickSetsPriced, aes(x = CPI, y = USAdjustedPrice)) +
geom_point(shape = 1)
tapply(brickSetsPriced$USRetailPrice, year, mean)
tapply(brickSetsPriced$USRetailPrice, brickSetsPriced$year, mean)
tapply(brickSetsPriced$USAdjustedPrice, brickSetsPriced$year, mean)
tapply(brickSetsPriced$USRetailPrice, brickSetsPriced$year, mean) -
tapply(brickSetsPriced$USAdjustedPrice, brickSetsPriced$year, mean)
round(tapply(brickSetsPriced$USRetailPrice, brickSetsPriced$year, mean))
round(tapply(brickSetsPriced$USAdjustedPrice, brickSetsPriced$year, mean))
pricesByYear <- data.frame(round(tapply(brickSetsPriced$USRetailPrice, brickSetsPriced$year, mean)))
adjustedPricesByYear <- data.frame(round(tapply(brickSetsPriced$USAdjustedPrice, brickSetsPriced$year, mean)))
pricesByYear <- merge(pricesByYear, adjustedPricesByYear)
View(pricesByYear)
names(pricesByYear) <- "retailPrice"
adjustedPricesByYear <- data.frame(round(tapply(brickSetsPriced$USAdjustedPrice, brickSetsPriced$year, mean)))
names(adjustedPricesByYear) <- "adjustedPrice"
pricesByYear$year <- row.names(pricesByYear)
adjustedPricesByYear$year <- row.names(adjustedPricesByYear)
pricesByYear <- merge(pricesByYear, adjustedPricesByYear)
View(pricesByYear)
pricesByYear$difference <- pricesByYear$adjustedPrice - pricesByYear$retailPrice
View(pricesByYear)
brickSetsPriced$priceAdjustment <- brickSetsPriced$USAdjustedPrice - brickSetsPriced$USRetailPrice
table(brickSetsPriced$priceAdjustment)
hist(brickSetsPriced$priceAdjustment)
hist(brickSetsPriced$priceAdjustment, breaks = 1000, xlim = (-100,100))
hist(brickSetsPriced$priceAdjustment, breaks = 1000, xlim = (-100:100))
hist(brickSetsPriced$priceAdjustment, breaks = 1000, xlim = c(-100,100))
rm(pricesByYear, adjustedPricesByYear)
rm(CPIAUCSL)
rm(avg.cpi, CPIAUCSL)
table(brickSetsPriced$pieces)
temp <- dfr_peeronPartsList(brickSetsPriced$legoID[1])
library(XML)
library(stringr)
temp <- dfr_peeronPartsList(brickSetsPriced$legoID[1])
View(temp)
partsList <- NULL
partsList <- NULL
for(i in nrow(brickSetsPriced):1) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
partsList <- rbind(tempPartsList, partsList)
print(i)
# }
}
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
partsList <- rbind(tempPartsList, partsList)
print(i)
# }
}
View(brickSetsPriced)
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(nrow(tempPartsList) > 0) {
partsList <- rbind(tempPartsList, partsList)
}
print(i)
# }
}
View(tempPartsList)
View(partsList)
table(partsList$SetID)
setIDString <- "375-1"
setURL <- str_peeronPartsListURL(setIDString)
setPartsListPage <- readHTMLTable(setURL)
setURL
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
length(setPartsList)
dfr_peeronPartsList <- function (setIDString) {
# Define the URL we're going to get
setURL <- str_peeronPartsListURL(setIDString)
# Now pull the page into an R object
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
# if it's a valid setAdd the setNumber to the data frame
if(length(setPartsList) > 0) {
setPartsList$SetID <- setIDString
# Use the function to clean the data frame
setPartsList <- dfr_cleanPeeronPartsList(setPartsList)
}
return(setPartsList)
}
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(nrow(tempPartsList) > 0) {
partsList <- rbind(tempPartsList, partsList)
}
print(i)
# }
}
brickSetsPriced$legoID[i]
str_peeronPartsListURL[brickSetsPriced$legoID[i]]
str_peeronPartsListURL(brickSetsPriced$legoID[i])
setIDString <- brickSetsPriced$legoID[i]
setURL <- str_peeronPartsListURL(setIDString)
temp <- dfr_peeronPartsList(setURL)
nrow(temp)
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(nrow(tempPartsList) > 0) {
partsList <- rbind(tempPartsList, partsList)
}
print(i)
# }
}
length(temp)
setIDString <- brickSetsPriced$legoID[i]
setURL <- str_peeronPartsListURL(setIDString)
temp <- dfr_peeronPartsList(setURL)
length(temp)
dfr_peeronPartsList <- function (setIDString) {
print(paste("Running", setIDString))
# Define the URL we're going to get
setURL <- str_peeronPartsListURL(setIDString)
# Now pull the page into an R object
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
# if it's a valid setAdd the setNumber to the data frame
if(length(setPartsList) > 0) {
setPartsList$SetID <- setIDString
# Use the function to clean the data frame
setPartsList <- dfr_cleanPeeronPartsList(setPartsList)
print(paste("Cleaned", setIDString))
}
return(setPartsList)
}
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(nrow(tempPartsList) > 0) {
partsList <- rbind(tempPartsList, partsList)
}
print(paste("Getting set in row", i))
# }
}
setPartsListPage <- readHTMLTable(setURL)
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
View(setPartsList)
length(setPartsList)
dfr_peeronPartsList <- function (setIDString) {
print(paste("Running", setIDString))
# Define the URL we're going to get
setURL <- str_peeronPartsListURL(setIDString)
# Now pull the page into an R object
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
# if it's a valid setAdd the setNumber to the data frame
if(length(setPartsList) > 1) {
setPartsList$SetID <- setIDString
# Use the function to clean the data frame
setPartsList <- dfr_cleanPeeronPartsList(setPartsList)
print(paste("Cleaned", setIDString))
}
return(setPartsList)
}
dfr_peeronPartsList <- function (setIDString) {
# print(paste("Running", setIDString))
# Define the URL we're going to get
setURL <- str_peeronPartsListURL(setIDString)
# Now pull the page into an R object
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
# if it's a valid setAdd the setNumber to the data frame
if(length(setPartsList) > 1) {
setPartsList$SetID <- setIDString
# Use the function to clean the data frame
setPartsList <- dfr_cleanPeeronPartsList(setPartsList)
# print(paste("Cleaned", setIDString))
}
return(setPartsList)
}
rm(partsList, setIDString, setPartsList, setPartsListPage, temp, tempPartsList)
rm(setURL)
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(nrow(tempPartsList) > 0) {
partsList <- rbind(tempPartsList, partsList)
}
print(paste("Getting set in row", i))
# }
}
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(length(tempPartsList) > 1) {
partsList <- rbind(tempPartsList, partsList)
}
print(paste("Getting set in row", i))
# }
}
temp <- dfr_peeronPartsList(brickSetsPriced$legoID[1])
setIDString <- brickSetsPriced$legoID[i]
(setIDString) <- brickSetsPriced$legoID[i]
(setIDString <- brickSetsPriced$legoID[i])
(setURL <- str_peeronPartsListURL(setIDString))
(temp <- dfr_peeronPartsList(setURL))
(length(temp))
View(tempPartsList)
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(length(tempPartsList) > 1) {
partsList <- rbind(tempPartsList, partsList)
}
print(paste("Getting set in row", i))
# }
}
View(partsList)
table(partsList$SetID)
View(brickSetsPriced)
setURL <- str_peeronPartsListURL(setIDString)
# Now pull the page into an R object
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
View(setPartsList)
dfr_peeronPartsList <- function (setIDString) {
# print(paste("Running", setIDString))
# Define the URL we're going to get
setURL <- str_peeronPartsListURL(setIDString)
# Now pull the page into an R object
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
# if it's a valid setAdd the setNumber to the data frame
if(length(setPartsList) > 2) {
setPartsList$SetID <- setIDString
# Use the function to clean the data frame
setPartsList <- dfr_cleanPeeronPartsList(setPartsList)
# print(paste("Cleaned", setIDString))
}
return(setPartsList)
}
rm(setIDString, setPartsList, setPartsListPage)
rm(setURL, temp, tempPartsList)
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(length(tempPartsList) > 1) {
partsList <- rbind(tempPartsList, partsList)
}
print(paste("Getting set in row", i))
# }
}
(setIDString <- brickSetsPriced$legoID[i])
(setURL <- str_peeronPartsListURL(setIDString))
(temp <- dfr_peeronPartsList(setURL))
(length(temp))
library(XML)
library(stringr)
(temp <- dfr_peeronPartsList(setURL))
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
length(setPartsList)
View(setPartsList)
View(setPartsList) > 2
length(setPartsList) > 2
View(partsList)
rm(temp, tempPartsList)
rm(setIDString, setPartsList, setPartsListPage)
rm(setURL)
rm(partsList)
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(length(tempPartsList) > 2) {
partsList <- rbind(tempPartsList, partsList)
}
print(paste("Getting set in row", i))
# }
}
(setIDString <- brickSetsPriced$legoID[i])
(setURL <- str_peeronPartsListURL(setIDString))
setPartsListPage <- readHTMLTable(setURL)
(setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)]))
names(setPartsList)[1] != "NULL.V1"
dfr_peeronPartsList <- function (setIDString) {
# print(paste("Running", setIDString))
# Define the URL we're going to get
setURL <- str_peeronPartsListURL(setIDString)
# Now pull the page into an R object
setPartsListPage <- readHTMLTable(setURL)
# Convert it to a data frame - the last table in the list should be what we want
setPartsList <- as.data.frame(setPartsListPage[length(setPartsListPage)])
# if it's a valid setAdd the setNumber to the data frame
validSet <- (length(setPartsList) > 1 &
names(setPartsList)[1] != "NULL.V1")
if(validSet) {
setPartsList$SetID <- setIDString
# Use the function to clean the data frame
setPartsList <- dfr_cleanPeeronPartsList(setPartsList)
# print(paste("Cleaned", setIDString))
return(setPartsList)
} else {
return(NA)
}
}
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
length(tempPartsList)
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(length(tempPartsList) > 1) {
partsList <- rbind(tempPartsList, partsList)
}
print(paste("Getting set in row", i))
# }
}
library(XML)
library(stringr)
rm(setIDString, setPartsList, setPartsListPage)
rm(tempPartsList, i)
rm(setURL)
partsList <- NULL
for(i in 1:nrow(brickSetsPriced)) {
# Now we can test the new function
# if(brickSetsPriced$pieces[i] > 2) {
tempPartsList <- dfr_peeronPartsList(brickSetsPriced$legoID[i])
if(length(tempPartsList) > 1) {
partsList <- rbind(tempPartsList, partsList)
}
print(paste("Getting set in row", i))
# }
}
length(table(partsList$SetID))
write.csv(partsList, "partsList.csv")

{
    "contents" : "# We're going to get all the parts lists for all the lego sets from the site brickset.com\n# Here's a sample URL: http://brickset.com/sets/theme-Action-Wheelers\n# http://brickset.com/sets/category-Normal/page-41\n# http://brickset.com/sets/year-1999\n# http://brickset.com/sets/2904-1/Motorbike\n# Note, all you need is the setID in the URL.\nrm(list = ls())\n# Here are the packages that you'll need:\nlibrary(XML)\nlibrary(stringr)\nlibrary(RCurl)\nlibrary(plyr)\napi.url <- \"http://brickset.com/api/v2.asmx/\"\napi.key <- \"IDzN-C1HU-99ud\"\nuname <- \"waketheman\"\npword <- \"serptin7\"\n\n\nu.hash <- getBricksetHashFromLogin(api.url, api.key, uname, pword)\nrm(uname, pword)\n\nyear <- 2014\nsets2014 <- getBricksetSetsByYear(api.url, api.key, u.hash, year = 2014)\n\n# some troubleshooting for i = 13 ----\nsetsByYear <- NULL\nfor (i in 1:245) {\n  temp <- getBricksetSetList(api.url, api.key, u.hash, year = 2014, pageNumber = i)\n  setsByYear <- rbind(setsByYear, temp)\n}\n\n# 121 is the equivalent to the first two on page 13\ni <- 246\ntemp <- getBricksetSetList(api.url, api.key, u.hash, \n                                  year = 2014,\n                                  pageSize = 1,\n                                  pageNumber = i)\nsetsByYear$amp <- str_detect(setsByYear$name, \"&\")\ntable(setsByYear$amp)\nsetsByYear <- arrange(setsByYear, desc(setsByYear$amp))\n\ngetBricksetSetsByYear <- function (api.url, api.key, u.hash, year) {\n# assumes that there is at least one set in the request\n  i <- 1\n  # start with the first one\n  setsByYear <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)\n  # if the function doesn't return false, there are more sets to get\n  moreSets <- !is.logical(setsByYear)\n  # keep going...\n  while (moreSets) {\n    i <- i + 1\n    temp <- getBricksetSetList(api.url, api.key, u.hash, year, pageNumber = i)\n    # if the function returns false, we've hit the end of the list\n    if (is.logical(temp)) {\n      moreSets <- FALSE\n    } else {\n      # Let's fix these so they have the same variables in the same order\n      # are they different lengths?\n      if (length(names(setsByYear)) > length(names(temp))) {\n        # the temp list is shorter (assume it has a subset of the variables) \n        # in the setsByYear list\n        colsToAdd <- setdiff(names(setsByYear), names(temp))\n        for (i in 1:length(colsToAdd)) {\n          # add another column, and set it's value to NA\n          temp[1, ncol(temp) + 1] <- NA\n          # name the last column in the df (the one just added)\n          # with the name of the next item in the array\n          names(temp)[ncol(temp)] <- colsToAdd[i]\n        }\n      }\n      if (length(names(temp)) > length(names(setsByYear))) {\n        # the setsByYear list is shorter (assume it has a subset of the variables) \n        # in the temp list\n        colsToAdd <- setdiff(names(temp), names(setsByYear))\n        for (i in 1:length(colsToAdd)) {\n          # add another column, and set it's value to NA\n          setsByYear[1, ncol(setsByYear) + 1] <- NA\n          # name the last column in the df (the one just added)\n          # with the name of the next item in the array\n          names(setsByYear)[ncol(setsByYear)] <- colsToAdd[i]\n        }\n      }\n      # now they are the same length\n      # do they have elements in the same order?\n      if (mean(as.numeric(names(setsByYear) == names(temp))) != 1) {\n        # if not, put them in the same order\n        temp <- temp[names(setsByYear)]\n      }\n      # now they have the same length, and are in the same order\n      setsByYear <- rbind(setsByYear, temp)\n    }\n  }\n  return(setsByYear)\n}\n\ngetBricksetSetList <- \n  function (api.url, api.key, u.hash, query = \"\", theme = \"\", subtheme = \"\",\n            setNumber = \"\", year = \"\", owned = \"\", wanted = \"\", orderBy = \"\", \n            pageSize = 1, pageNumber = \"\", userName = \"\") {\n    # testing:\n    # query <- \"\"\n    # theme <- \"\"\n    # subtheme <- \"\"\n    # setNumber <- \"\"\n    # year <- 2014\n    # owned <- \"\"\n    # wanted <- \"\"\n    # orderBy <- \"\"\n    # pageSize <- \"\"\n    # pageNumber <- \"\"\n    # userName <- \"\"\n    # here's what we need:\n    param.setsList <- \"getSets?\"\n    params.key <- paste(\"apiKey=\", api.key, sep = \"\")\n    setslist.uri <- paste(api.url, param.setsList, params.key, sep = \"\")\n    params.uh <- paste(\"userHash=\", u.hash, sep = \"\")\n    params.query <- paste(\"query=\", query, sep = \"\")\n    params.theme <- paste(\"theme=\", theme, sep = \"\")\n    params.subtheme <- paste(\"subtheme=\", subtheme, sep = \"\")\n    params.setNumber <- paste(\"setNumber=\", setNumber, sep = \"\")\n    params.year <- paste(\"year=\", year, sep = \"\")\n    params.owned <- paste(\"owned=\", owned, sep = \"\")\n    params.wanted <- paste(\"wanted=\", wanted, sep = \"\")\n    params.orderBy <- paste(\"orderBy=\", orderBy, sep = \"\")\n    params.pageSize <- paste(\"pageSize=\", pageSize, sep = \"\")\n    params.pageNumber <- paste(\"pageNumber=\", pageNumber, sep = \"\")\n    params.userName <- paste(\"userName=\", userName, sep = \"\")\n    sets.string <- \n      paste(setslist.uri, params.uh, params.query, params.theme, params.subtheme, \n            params.setNumber, params.year, params.owned, params.wanted, \n            params.orderBy, params.pageSize, params.pageNumber, params.userName,\n            sep = \"&\")\n    # Now reach out to the api\n    html.sets <- getURL(sets.string)\n    # Now make it an XML document\n    xml.sets <- xmlInternalTreeParse(html.sets)\n    xml <- xmlRoot(xml.sets)\n    # did they give us a list of sets?\n    if (xmlSize(xml) > 0) {\n      # Yes\n      # try with xmlSApply\n      sets.t <- xmlSApply(xml, function(x) xmlSApply(x, xmlValue))\n      # it works but it's the wrong orientation\n      sets <- as.data.frame(t(sets.t))\n      row.names(sets) <- sets$setID\n      # now convert all the factors into strings\n      sets <- data.frame(lapply(sets, as.character), stringsAsFactors = FALSE)\n    } else {\n      # No - the list is empty\n      sets <- FALSE\n    }\n    return (sets)\n  }\n\ngetBricksetHashFromLogin <- function (api.url, api.key, uname, pword) {\n  param.login <- \"login?\"\n  params.key <- paste(\"apiKey=\", api.key, sep = \"\")\n  login.url <- paste(api.url, param.login, params.key, sep = \"\")\n  params.uname <- paste(\"username=\", uname, sep = \"\")\n  params.pword <- paste(\"password=\", pword, sep = \"\")\n  login.string <- paste(login.url, params.uname, params.pword, sep = \"&\")\n  u.hash.xml <- xmlInternalTreeParse(getURL(login.string))\n  # login works!!\n  # now extract the hash ----\n  u.hash <- xmlValue(xmlRoot(u.hash.xml)[[1]])\n  return(u.hash)\n}\n\n",
    "created" : 1422297670668.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3529693092",
    "id" : "B1DDA2D1",
    "lastKnownWriteTime" : 1426281755,
    "path" : "~/Documents/github/lego-pricing/brickset/1-lego_set_data_collection.R",
    "project_path" : "brickset/1-lego_set_data_collection.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}